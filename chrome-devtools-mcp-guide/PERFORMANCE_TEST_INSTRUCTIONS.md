# Chrome DevTools MCP - パフォーマンステスト指示書

## 概要

このドキュメントでは、Chrome DevTools MCPを使用してサンプルサイトのパフォーマンスを測定する際の具体的な指示方法を示します。

---

## 1. 基本的なパフォーマンス測定

### 指示例1: 初期ページロードのパフォーマンス

```
Chrome DevTools MCPを使用して、以下のパフォーマンス測定を実行してください:

URL: http://127.0.0.1:5500/sample-site/index.html

測定項目:
1. ページロード時間
   - DOMContentLoaded までの時間
   - Load イベントまでの時間
   - First Paint までの時間

2. Core Web Vitals
   - LCP (Largest Contentful Paint)
   - FID (First Input Delay)
   - CLS (Cumulative Layout Shift)

3. リソース読み込み
   - HTML ファイルのサイズとロード時間
   - CSS ファイルのサイズとロード時間
   - JavaScript ファイルのサイズとロード時間

4. レンダリング
   - DOM要素数
   - 初期レンダリング時間

結果を表形式でレポートしてください。
```

---

## 2. 境界値でのパフォーマンス比較

### 指示例2: データ件数によるパフォーマンス変化

```
Chrome DevTools MCPを使用して、データ件数の違いによるパフォーマンスの変化を測定してください:

URL: http://127.0.0.1:5500/sample-site/index.html

## シナリオ1: 0件の状態
1. ページを開く
2. 以下を測定:
   - DOM要素数
   - メモリ使用量（ヒープサイズ）
   - レンダリング時間
3. スクリーンショットを取得

## シナリオ2: 20件の状態（ページング境界）
1. フォームから20件のデータを追加
   - 名前: テストユーザー1〜20
   - メール: user1@example.com〜user20@example.com
   - 年齢: 25〜44
2. 以下を測定:
   - DOM要素数の増加
   - メモリ使用量の増加
   - テーブルのレンダリング時間
3. スクリーンショットを取得

## シナリオ3: 50件の状態（3ページ分）
1. さらに30件追加（合計50件）
2. 以下を測定:
   - DOM要素数の増加
   - メモリ使用量の増加
   - ページング表示後のレンダリング時間
3. スクリーンショットを取得

## シナリオ4: ページ遷移のパフォーマンス
1. 1ページ目から2ページ目に移動
2. ページ遷移時のレンダリング時間を測定
3. DOM更新にかかる時間を測定

## 比較レポート
以下の形式で結果を比較:

| 状態 | DOM要素数 | メモリ(MB) | レンダリング(ms) |
|------|----------|-----------|----------------|
| 0件  | XXX      | X.XX      | XXX            |
| 20件 | XXX      | X.XX      | XXX            |
| 50件 | XXX      | X.XX      | XXX            |

パフォーマンスの劣化度合いと、改善すべき点を提案してください。
```

---

## 3. ネットワークパフォーマンス測定

### 指示例3: データ追加時のネットワークトラフィック

```
Chrome DevTools MCPを使用して、フォーム送信時のネットワークパフォーマンスを測定してください:

URL: http://127.0.0.1:5500/sample-site/index.html

注意: このサンプルサイトはバックエンドがなく、すべてクライアント側で動作します。
そのため、実際のHTTPリクエストは発生しませんが、以下を確認してください:

## 測定項目

1. 初期ページロード時のリクエスト
   - HTML, CSS, JS の各リクエスト
   - レスポンスサイズ
   - レスポンスタイム
   - キャッシュの状態

2. フォーム送信時の動作
   - JavaScriptの実行時間
   - DOM更新にかかる時間
   - 画面の再描画時間

3. ページ遷移時の動作
   - DOMの更新範囲
   - 再レンダリングの範囲

## レポート形式

リソース別の読み込み時間:
- index.html: XXX ms (XX KB)
- styles.css: XXX ms (XX KB)
- app.js: XXX ms (XX KB)

操作別のレスポンスタイム:
- フォーム送信: XXX ms
- ページ遷移: XXX ms
- データ削除: XXX ms
```

---

## 4. メモリリーク検出

### 指示例4: 繰り返し操作でのメモリ使用量追跡

```
Chrome DevTools MCPを使用して、繰り返し操作時のメモリリークを検出してください:

URL: http://127.0.0.1:5500/sample-site/index.html

## テストシナリオ

### ステップ1: 初期状態のメモリ測定
1. ページを開く
2. 初期メモリ使用量を記録（ヒープサイズ）

### ステップ2: データ追加と削除の繰り返し
以下の操作を10回繰り返し、各回でメモリを測定:

1. データを10件追加
2. メモリ使用量を記録
3. 追加した10件を削除
4. メモリ使用量を記録
5. ガベージコレクションを強制実行
6. メモリ使用量を記録

### ステップ3: 分析
- 操作前後でメモリが解放されているか
- メモリ使用量が増加し続けていないか
- 10回の繰り返し後、初期状態と比較してメモリ増加があるか

## 期待される結果
メモリリークがない場合:
- 削除後、メモリが元のレベルに戻る
- 繰り返し後も、メモリ使用量が大幅に増加していない

## レポート形式
| 操作 | メモリ(MB) | 増減 |
|------|-----------|------|
| 初期 | X.XX      | -    |
| 10件追加後 | X.XX | +X.XX |
| 削除後 | X.XX | -X.XX |
| GC後 | X.XX | -X.XX |

メモリリークの有無と、問題がある場合は原因の推測を含めてください。
```

---

## 5. レスポンシブデザインのパフォーマンス

### 指示例5: 複数ビューポートでのパフォーマンス測定

```
Chrome DevTools MCPを使用して、異なるビューポートサイズでのパフォーマンスを比較してください:

URL: http://127.0.0.1:5500/sample-site/index.html

前提条件: 20件のデータを追加した状態

## テスト対象のビューポート

1. モバイル (375x667)
   - iPhone SE サイズ
2. タブレット (768x1024)
   - iPad サイズ
3. デスクトップ (1920x1080)
   - フルHD

## 各ビューポートで測定

1. ページロード時間
2. レンダリング時間
3. DOM要素数
4. メモリ使用量
5. スクリーンショット

## 追加確認項目

各ビューポートで:
- レイアウトが崩れていないか
- すべての要素が適切に表示されているか
- フォントサイズが読みやすいか
- ボタンがタップしやすいサイズか

## レポート形式

| ビューポート | ロード(ms) | レンダリング(ms) | メモリ(MB) |
|------------|-----------|----------------|-----------|
| Mobile     | XXX       | XXX            | X.XX      |
| Tablet     | XXX       | XXX            | X.XX      |
| Desktop    | XXX       | XXX            | X.XX      |

各サイズでのスクリーンショットを添付し、レイアウトの問題があれば指摘してください。
```

---

## 6. JavaScript実行パフォーマンス

### 指示例6: JavaScript関数の実行時間測定

```
Chrome DevTools MCPを使用して、主要なJavaScript関数の実行時間を測定してください:

URL: http://127.0.0.1:5500/sample-site/index.html

## 測定対象の操作

1. フォーム送信（データ追加）
   - バリデーション処理の実行時間
   - データストアへの追加時間
   - テーブルのレンダリング時間

2. ページ遷移
   - ページ計算の実行時間
   - DOM更新の実行時間
   - レンダリングの実行時間

3. データ削除
   - データストアからの削除時間
   - テーブルの再描画時間
   - ページ情報の更新時間

## パフォーマンスプロファイリング

1. パフォーマンスプロファイルを開始
2. 各操作を実行
3. プロファイルを停止
4. 以下を分析:
   - 最も時間がかかっている関数
   - ボトルネックとなっている処理
   - 最適化が可能な箇所

## レポート形式

関数別実行時間:
- validateName(): XXX ms
- validateEmail(): XXX ms
- validateAge(): XXX ms
- addData(): XXX ms
- renderTable(): XXX ms
- goToPage(): XXX ms
- deleteItem(): XXX ms

最適化提案:
1. [関数名]: [提案内容]
2. [関数名]: [提案内容]
```

---

## 7. 長時間使用時のパフォーマンス

### 指示例7: 長時間操作でのパフォーマンス劣化測定

```
Chrome DevTools MCPを使用して、長時間の使用によるパフォーマンス劣化を測定してください:

URL: http://127.0.0.1:5500/sample-site/index.html

## テストシナリオ: 100件のデータを段階的に追加

1. 初期状態のパフォーマンスを記録

2. 以下を繰り返し実行（合計100件まで）:
   - 10件のデータを追加
   - パフォーマンスメトリクスを記録
   - データ追加にかかった時間を記録

3. 各段階（10件、20件、30件...100件）で:
   - メモリ使用量
   - DOM要素数
   - レンダリング時間
   - JavaScript実行時間
   を測定

4. 100件に達したら:
   - ページ遷移のパフォーマンスを測定
   - 各ページ（1〜5ページ）の表示時間を比較

## 分析ポイント

- データ量に比例してパフォーマンスが劣化しているか
- 特定の境界値（20件、40件など）でパフォーマンスが急激に変化しないか
- メモリ使用量が線形に増加しているか、それとも指数関数的か

## レポート形式

グラフまたは表形式で:
- X軸: データ件数（10, 20, 30...100）
- Y軸: パフォーマンス指標（メモリ、レンダリング時間など）

| 件数 | メモリ(MB) | レンダリング(ms) | 追加操作(ms) |
|------|-----------|----------------|-------------|
| 10   | X.XX      | XXX            | XXX         |
| 20   | X.XX      | XXX            | XXX         |
| ...  | ...       | ...            | ...         |
| 100  | X.XX      | XXX            | XXX         |

パフォーマンス劣化の傾向と、推奨される最大データ件数を提案してください。
```

---

## 8. 統合パフォーマンステスト

### 指示例8: 包括的なパフォーマンス評価

```
Chrome DevTools MCPを使用して、サンプルサイトの包括的なパフォーマンス評価を実施してください:

URL: http://127.0.0.1:5500/sample-site/index.html

## 評価カテゴリ

### 1. 初期ロードパフォーマンス
- ページロード時間
- Core Web Vitals
- リソース読み込み時間
- 初期レンダリング時間

### 2. ランタイムパフォーマンス
- フォーム入力のレスポンス時間
- データ追加の処理時間
- ページ遷移の速度
- データ削除の処理時間

### 3. メモリ管理
- 初期メモリ使用量
- データ増加に伴うメモリ増加
- メモリリークの有無
- ガベージコレクションの効率

### 4. レンダリングパフォーマンス
- 初期レンダリング
- 再レンダリング（データ追加時）
- ページ遷移時の再描画
- レイアウトシフトの有無

### 5. スケーラビリティ
- 小規模データ（1-20件）でのパフォーマンス
- 中規模データ（21-50件）でのパフォーマンス
- 大規模データ（51-100件）でのパフォーマンス

## 総合評価レポート

以下の形式で総合評価を作成:

### パフォーマンススコア（100点満点）
- 初期ロード: XX/20
- ランタイム: XX/20
- メモリ管理: XX/20
- レンダリング: XX/20
- スケーラビリティ: XX/20
- **総合スコア: XX/100**

### 主な発見事項
1. [良い点]
2. [改善が必要な点]
3. [潜在的な問題]

### 改善提案（優先度順）
1. **高優先度**: [提案内容]
2. **中優先度**: [提案内容]
3. **低優先度**: [提案内容]

### パフォーマンス最適化のチェックリスト
- [ ] 不要なDOM要素の削除
- [ ] JavaScriptの最適化
- [ ] イベントリスナーの最適化
- [ ] メモリリークの修正
- [ ] レンダリングの最適化

詳細なデータと具体的な改善策を含めてください。
```

---

## 9. 自動化スクリプトの例

### Chrome DevTools MCPを使った自動測定スクリプトの指示

```
Chrome DevTools MCPを使用して、定期的にパフォーマンスを測定する自動化スクリプトの概念を実装してください:

## 目的
CI/CDパイプラインに組み込むことを想定した、自動パフォーマンステスト

## 要件

1. 複数のシナリオを自動実行
   - 0件、20件、50件、100件のデータでテスト

2. 閾値チェック
   - ページロード時間が3秒以内
   - メモリ使用量が50MB以内
   - LCPが2.5秒以内

3. レポート生成
   - JSON形式でメトリクスを出力
   - 閾値超過があればアラート
   - トレンドデータの保存

4. スクリーンショット保存
   - 各シナリオでスクリーンショット取得
   - タイムスタンプ付きでファイル保存

## 実装例（疑似コード）

```javascript
// 測定シナリオの定義
const scenarios = [
  { name: '0件', dataCount: 0 },
  { name: '20件', dataCount: 20 },
  { name: '50件', dataCount: 50 },
  { name: '100件', dataCount: 100 }
];

// 閾値の定義
const thresholds = {
  loadTime: 3000,      // 3秒
  memoryUsage: 50,     // 50MB
  lcp: 2500            // 2.5秒
};

// 各シナリオを実行
for (scenario of scenarios) {
  // データ準備
  // パフォーマンス測定
  // 閾値チェック
  // レポート保存
}
```

このような自動化の概念を、Chrome DevTools MCPの機能を使って実現する方法を提案してください。
```

---

## 付録: よく使うメトリクスの説明

### Core Web Vitals

- **LCP (Largest Contentful Paint)**
  - 最大コンテンツの描画時間
  - 目標: 2.5秒以内

- **FID (First Input Delay)**
  - 最初の入力までの遅延
  - 目標: 100ms以内

- **CLS (Cumulative Layout Shift)**
  - レイアウトシフトの累積
  - 目標: 0.1以下

### その他の重要なメトリクス

- **TTFB (Time to First Byte)**
  - 最初のバイト受信までの時間

- **FCP (First Contentful Paint)**
  - 最初のコンテンツ描画時間

- **TTI (Time to Interactive)**
  - インタラクティブになるまでの時間

- **Total Blocking Time**
  - メインスレッドがブロックされている合計時間

---

**作成日**: 2025年10月25日
**最終更新**: 2025年10月25日
